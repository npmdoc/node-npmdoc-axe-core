<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/dequelabs/axe-core#readme">axe-core (v2.1.7)</a>
</h1>
<h4>Accessibility engine for automated Web UI testing</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.axe-core">module axe-core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core._load">
            function <span class="apidocSignatureSpan">axe-core.</span>_load
            <span class="apidocSignatureSpan">(audit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core._runRules">
            function <span class="apidocSignatureSpan">axe-core.</span>_runRules
            <span class="apidocSignatureSpan">(context, options, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.a11yCheck">
            function <span class="apidocSignatureSpan">axe-core.</span>a11yCheck
            <span class="apidocSignatureSpan">(context, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.addReporter">
            function <span class="apidocSignatureSpan">axe-core.</span>addReporter
            <span class="apidocSignatureSpan">(name, cb, isDefault)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.cleanup">
            function <span class="apidocSignatureSpan">axe-core.</span>cleanup
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.configure">
            function <span class="apidocSignatureSpan">axe-core.</span>configure
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.getReporter">
            function <span class="apidocSignatureSpan">axe-core.</span>getReporter
            <span class="apidocSignatureSpan">(reporter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.getRules">
            function <span class="apidocSignatureSpan">axe-core.</span>getRules
            <span class="apidocSignatureSpan">(tags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.log">
            function <span class="apidocSignatureSpan">axe-core.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.registerPlugin">
            function <span class="apidocSignatureSpan">axe-core.</span>registerPlugin
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.reset">
            function <span class="apidocSignatureSpan">axe-core.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.run">
            function <span class="apidocSignatureSpan">axe-core.</span>run
            <span class="apidocSignatureSpan">(context, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.DqElement">
            function <span class="apidocSignatureSpan">axe-core.</span>utils.DqElement
            <span class="apidocSignatureSpan">(element, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.respondable">
            function <span class="apidocSignatureSpan">axe-core.</span>utils.respondable
            <span class="apidocSignatureSpan">(win, topic, message, keepalive, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">axe-core.</span>_audit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">axe-core.</span>commons</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">axe-core.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">axe-core.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">axe-core.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">axe-core.</span>utils.DqElement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">axe-core.</span>source</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">axe-core.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.axe-core.utils">module axe-core.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.DqElement">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>DqElement
            <span class="apidocSignatureSpan">(element, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.aggregate">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregate
            <span class="apidocSignatureSpan">(map, values, initial)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.aggregateChecks">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregateChecks
            <span class="apidocSignatureSpan">(nodeResOriginal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.aggregateResult">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregateResult
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.aggregateRule">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregateRule
            <span class="apidocSignatureSpan">(subResults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.areStylesSet">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>areStylesSet
            <span class="apidocSignatureSpan">(el, styles, stopAt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.checkHelper">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>checkHelper
            <span class="apidocSignatureSpan">(checkResult, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.clone">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.collectResultsFromFrames">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>collectResultsFromFrames
            <span class="apidocSignatureSpan">(context, options, command, parameter, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.contains">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>contains
            <span class="apidocSignatureSpan">(node, otherNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.escapeSelector">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>escapeSelector
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.extendMetaData">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>extendMetaData
            <span class="apidocSignatureSpan">(to, from)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.finalizeRuleResult">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>finalizeRuleResult
            <span class="apidocSignatureSpan">(ruleResult)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.findBy">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>findBy
            <span class="apidocSignatureSpan">(array, key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.getAllChecks">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>getAllChecks
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.getCheckOption">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>getCheckOption
            <span class="apidocSignatureSpan">(check, ruleID, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.getSelector">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>getSelector
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.getXpath">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>getXpath
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.injectStyle">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>injectStyle
            <span class="apidocSignatureSpan">(style)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.isHidden">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>isHidden
            <span class="apidocSignatureSpan">(el, recursed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.matchesSelector">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>matchesSelector
            <span class="apidocSignatureSpan">(node, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.mergeResults">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>mergeResults
            <span class="apidocSignatureSpan">(frameResults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.nodeSorter">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>nodeSorter
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.pollyfillElementsFromPoint">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>pollyfillElementsFromPoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.publishMetaData">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>publishMetaData
            <span class="apidocSignatureSpan">(ruleResult)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.queue">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>queue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.respondable">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>respondable
            <span class="apidocSignatureSpan">(win, topic, message, keepalive, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.ruleShouldRun">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>ruleShouldRun
            <span class="apidocSignatureSpan">(rule, context, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.select">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>select
            <span class="apidocSignatureSpan">(selector, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.sendCommandToFrame">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>sendCommandToFrame
            <span class="apidocSignatureSpan">(node, parameters, resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.toArray">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>toArray
            <span class="apidocSignatureSpan">(thing)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.tokenList">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>tokenList
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.axe-core.utils.DqElement">module axe-core.utils.DqElement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.DqElement.DqElement">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>DqElement
            <span class="apidocSignatureSpan">(element, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.DqElement.fromFrame">
            function <span class="apidocSignatureSpan">axe-core.utils.DqElement.</span>fromFrame
            <span class="apidocSignatureSpan">(node, frame)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.axe-core.utils.DqElement.prototype">module axe-core.utils.DqElement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.DqElement.prototype.toJSON">
            function <span class="apidocSignatureSpan">axe-core.utils.DqElement.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.axe-core.utils.respondable">module axe-core.utils.respondable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.respondable.respondable">
            function <span class="apidocSignatureSpan">axe-core.utils.</span>respondable
            <span class="apidocSignatureSpan">(win, topic, message, keepalive, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.respondable.isInFrame">
            function <span class="apidocSignatureSpan">axe-core.utils.respondable.</span>isInFrame
            <span class="apidocSignatureSpan">(win)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.axe-core.utils.respondable.subscribe">
            function <span class="apidocSignatureSpan">axe-core.utils.respondable.</span>subscribe
            <span class="apidocSignatureSpan">(topic, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.axe-core" id="apidoc.module.axe-core">module axe-core</a></h1>


    <h2>
        <a href="#apidoc.element.axe-core._load" id="apidoc.element.axe-core._load">
        function <span class="apidocSignatureSpan">axe-core.</span>_load
        <span class="apidocSignatureSpan">(audit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_load = function (audit) {
  'use strict';
  axe.utils.respondable.subscribe('axe.ping', function(data, keepalive, respond) {
    respond({
      axe: true
    });
  });
  axe.utils.respondable.subscribe('axe.start', runCommand);
  axe._audit = new Audit(audit);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;
})(window);
'use strict';
axe.<span class="apidocCodeKeywordSpan">_load</span>({
  data: {
    rules: {
      accesskeys: {
        description: 'Ensures every accesskey attribute value is unique',
        help: 'accesskey attribute value must be unique'
      },
      'area-alt': {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core._runRules" id="apidoc.element.axe-core._runRules">
        function <span class="apidocSignatureSpan">axe-core.</span>_runRules
        <span class="apidocSignatureSpan">(context, options, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runRules(context, options, resolve, reject) {
  'use strict';
  context = new Context(context);
  var q = axe.utils.queue();
  var audit = axe._audit;
  if (context.frames.length) {
    q.defer(function(res, rej) {
      axe.utils.collectResultsFromFrames(context, options, 'rules', null, res, rej);
    });
  }
  q.defer(function(res, rej) {
    audit.run(context, options, res, rej);
  });
  q.then(function(data) {
    try {
      // Add wrapper object so that we may use the same "merge" function for results from inside and outside frames
      var results = axe.utils.mergeResults(data.map(function(d) {
        return {
          results: d
        };
      }));
      // after should only run once, so ensure we are in the top level window
      if (context.initiator) {
        results = audit.after(results, options);
        results.forEach(axe.utils.publishMetaData);
        results = results.map(axe.utils.finalizeRuleResult);
      }
      try {
        resolve(results);
      } catch (e) {
        axe.log(e);
      }
    } catch (e) {
      reject(e);
    }
  }).catch(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  var audit = axe._audit;
  if (!audit) {
    throw new Error('No audit configured');
  }
  options.reporter = options.reporter || audit.reporter || 'v2';
  var reporter = axe.getReporter(options.reporter);
  axe.<span class="apidocCodeKeywordSpan">_runRules</span>(context, options, function(results) {
    var res = reporter(results, options, callback);
    if (res !== undefined) {
      callback(res);
    }
  }, axe.log);
};
'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.a11yCheck" id="apidoc.element.axe-core.a11yCheck">
        function <span class="apidocSignatureSpan">axe-core.</span>a11yCheck
        <span class="apidocSignatureSpan">(context, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">a11yCheck = function (context, options, callback) {
  'use strict';
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  if (!options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
    options = {};
  }
  var audit = axe._audit;
  if (!audit) {
    throw new Error('No audit configured');
  }
  options.reporter = options.reporter || audit.reporter || 'v2';
  var reporter = axe.getReporter(options.reporter);
  axe._runRules(context, options, function(results) {
    var res = reporter(results, options, callback);
    if (res !== undefined) {
      callback(res);
    }
  }, axe.log);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.addReporter" id="apidoc.element.axe-core.addReporter">
        function <span class="apidocSignatureSpan">axe-core.</span>addReporter
        <span class="apidocSignatureSpan">(name, cb, isDefault)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function registerReporter(name, cb, isDefault) {
  'use strict';
  reporters[name] = cb;
  if (isDefault) {
    defaultReporter = cb;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return ruleResult;
    });
  });
  return resultObject;
};
'use strict';
/*global helpers */
axe.<span class="apidocCodeKeywordSpan">addReporter</span>('na', function(results, options, callback) {
  'use strict';
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  var out = helpers.processAggregate(results, options);
  callback({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.cleanup" id="apidoc.element.axe-core.cleanup">
        function <span class="apidocSignatureSpan">axe-core.</span>cleanup
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanupPlugins(resolve, reject) {
  'use strict';
  if (!axe._audit) {
    throw new Error('No audit configured');
  }
  var q = axe.utils.queue();
  // If a plugin fails it's cleanup, we still want the others to run
  var cleanupErrors = [];
  Object.keys(axe.plugins).forEach(function(key) {
    q.defer(function(res) {
      var rej = function rej(err) {
        cleanupErrors.push(err);
        res();
      };
      try {
        axe.plugins[key].cleanup(res, rej);
      } catch (err) {
        rej(err);
      }
    });
  });
  axe.utils.toArray(document.querySelectorAll('frame, iframe')).forEach(function(frame) {
    q.defer(function(res, rej) {
      return axe.utils.sendCommandToFrame(frame, {
        command: 'cleanup-plugin'
      }, res, rej);
    });
  });
  q.then(function(results) {
    if (cleanupErrors.length === 0) {
      resolve(results);
    } else {
      reject(cleanupErrors);
    }
  }).catch(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Object.keys(axe.plugins).forEach(function(key) {
  q.defer(function(res) {
    var rej = function rej(err) {
      cleanupErrors.push(err);
      res();
    };
    try {
      axe.plugins[key].<span class="apidocCodeKeywordSpan">cleanup</span>(res, rej);
    } catch (err) {
      rej(err);
    }
  });
});
axe.utils.toArray(document.querySelectorAll('frame, iframe')).forEach(function(frame) {
  q.defer(function(res, rej) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.configure" id="apidoc.element.axe-core.configure">
        function <span class="apidocSignatureSpan">axe-core.</span>configure
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function configureChecksRulesAndBranding(spec) {
  'use strict';
  var audit;
  audit = axe._audit;
  if (!audit) {
    throw new Error('No audit configured');
  }
  if (spec.reporter &amp;&amp; (typeof spec.reporter === 'function' || reporters[spec.reporter])) {
    audit.reporter = spec.reporter;
  }
  if (spec.checks) {
    spec.checks.forEach(function(check) {
      audit.addCheck(check);
    });
  }
  if (spec.rules) {
    spec.rules.forEach(function(rule) {
      audit.addRule(rule);
    });
  }
  if (typeof spec.branding !== 'undefined') {
    audit.setBranding(spec.branding);
  } else {
    audit._constructHelpUrls();
  }
  if (spec.tagExclude) {
    audit.tagExclude = spec.tagExclude;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 Audit.prototype.addRule = function(spec) {
   'use strict';
   if (spec.metadata) {
     this.data.rules[spec.id] = spec.metadata;
   }
   var rule = this.getRule(spec.id);
   if (rule) {
     rule.<span class="apidocCodeKeywordSpan">configure</span>(spec);
   } else {
     this.rules.push(new Rule(spec, this));
   }
 };
 /**
* Adds a new check to the Audit.  If a Check with specified ID already exists, it will be
* reconfigured
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.getReporter" id="apidoc.element.axe-core.getReporter">
        function <span class="apidocSignatureSpan">axe-core.</span>getReporter
        <span class="apidocSignatureSpan">(reporter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getReporter = function (reporter) {
  'use strict';
  if (typeof reporter === 'string' &amp;&amp; reporters[reporter]) {
    return reporters[reporter];
  }
  if (typeof reporter === 'function') {
    return reporter;
  }
  return defaultReporter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options = {};
  }
  var audit = axe._audit;
  if (!audit) {
    throw new Error('No audit configured');
  }
  options.reporter = options.reporter || audit.reporter || 'v2';
  var reporter = axe.<span class="apidocCodeKeywordSpan">getReporter</span>(options.reporter);
  axe._runRules(context, options, function(results) {
    var res = reporter(results, options, callback);
    if (res !== undefined) {
      callback(res);
    }
  }, axe.log);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.getRules" id="apidoc.element.axe-core.getRules">
        function <span class="apidocSignatureSpan">axe-core.</span>getRules
        <span class="apidocSignatureSpan">(tags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRules = function (tags) {
  'use strict';
  tags = tags || [];
  var matchingRules = !tags.length ? axe._audit.rules : axe._audit.rules.filter(function(item) {
    return !!tags.filter(function(tag) {
      return item.tags.indexOf(tag) !== -1;
    }).length;
  });
  var ruleData = axe._audit.data.rules || {};
  return matchingRules.map(function(matchingRule) {
    var rd = ruleData[matchingRule.id] || {};
    return {
      ruleId: matchingRule.id,
      description: rd.description,
      help: rd.help,
      helpUrl: rd.helpUrl,
      tags: matchingRule.tags
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.log" id="apidoc.element.axe-core.log">
        function <span class="apidocSignatureSpan">axe-core.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  'use strict';
  if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object' &amp;&amp; console.log) {
    // IE does not support console.log.apply
    Function.prototype.apply.call(console.log, console, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        results = audit.after(results, options);
        results.forEach(axe.utils.publishMetaData);
        results = results.map(axe.utils.finalizeRuleResult);
      }
      try {
        resolve(results);
      } catch (e) {
        axe.<span class="apidocCodeKeywordSpan">log</span>(e);
      }
    } catch (e) {
      reject(e);
    }
  }).catch(reject);
}
axe._runRules = runRules;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.registerPlugin" id="apidoc.element.axe-core.registerPlugin">
        function <span class="apidocSignatureSpan">axe-core.</span>registerPlugin
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerPlugin = function (plugin) {
  'use strict';
  axe.plugins[plugin.id] = new Plugin(plugin);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.reset" id="apidoc.element.axe-core.reset">
        function <span class="apidocSignatureSpan">axe-core.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resetConfiguration() {
  'use strict';
  var audit = axe._audit;
  if (!audit) {
    throw new Error('No audit configured');
  }
  audit.resetRulesAndChecks();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.run" id="apidoc.element.axe-core.run">
        function <span class="apidocSignatureSpan">axe-core.</span>run
        <span class="apidocSignatureSpan">(context, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (context, options, callback) {
  'use strict';
  if (!axe._audit) {
    throw new Error('No audit configured');
  }
  var args = normalizeRunParams(context, options, callback);
  context = args.context;
  options = args.options;
  callback = args.callback;
  // set defaults:
  options.reporter = options.reporter || axe._audit.reporter || 'v1';
  var p = void 0;
  var reject = noop;
  var resolve = noop;
  if (window.Promise &amp;&amp; callback === noop) {
    p = new Promise(function(_resolve, _reject) {
      reject = _reject;
      resolve = _resolve;
    });
  }
  axe._runRules(context, options, function(rawResults) {
    var respond = function respond(results) {
      try {
        callback(null, results);
      } catch (e) {
        axe.log(e);
      }
      resolve(results);
    };
    try {
      var reporter = axe.getReporter(options.reporter);
      var results = reporter(rawResults, options, respond);
      if (results !== undefined) {
        respond(results);
      }
    } catch (err) {
      callback(err);
      reject(err);
    }
  }, function(err) {
    callback(err);
    reject(err);
  });
  return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```html
&lt;script src="node_modules/axe-core/axe.min.js" &gt;&lt;/script&gt;
```

Now insert calls at each point in your tests where a new piece of UI becomes visible or exposed:

```js
axe.<span class="apidocCodeKeywordSpan">run</span>(function (err, results) {
	if (err) throw err;
    ok(results.violations.length === 0, 'Should be no accessibility issues');
    // complete the async call
    ...
});
```
## Supported Browsers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.DqElement" id="apidoc.element.axe-core.utils.DqElement">
        function <span class="apidocSignatureSpan">axe-core.</span>utils.DqElement
        <span class="apidocSignatureSpan">(element, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DqElement(element, spec) {
  'use strict';
  spec = spec || {};
<span class="apidocCodeCommentSpan">  /**
* A unique CSS selector for the element
* @type {String}
*/
</span>  this.selector = spec.selector || [ axe.utils.getSelector(element) ];
  /**
* Xpath to the element
*/
  this.xpath = spec.xpath || [ axe.utils.getXpath(element) ];
  /**
* The generated HTML source code of the element
* @type {String}
*/
  this.source = spec.source !== undefined ? spec.source : getSource(element);
  /**
* The element which this object is based off or the containing frame, used for sorting.
* Excluded in toJSON method.
* @type {HTMLElement}
*/
  this.element = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          });
          result[r.type] = res;
          if (res.length) {
            hasResults = true;
          }
        });
        if (hasResults) {
          result.node = new axe.<span class="apidocCodeKeywordSpan">utils.DqElement</span>(node);
          ruleResult.nodes.push(result);
        }
      }
      resolveNode();
    }).catch(rejectNode);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.respondable" id="apidoc.element.axe-core.utils.respondable">
        function <span class="apidocSignatureSpan">axe-core.</span>utils.respondable
        <span class="apidocSignatureSpan">(win, topic, message, keepalive, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function respondable(win, topic, message, keepalive, callback) {
  var id = uuid.v1();
  post(win, topic, message, id, keepalive, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      resolve(null);
    } else {
      reject(errMsg);
    }
  }, 0);
}, 500);
// send 'axe.ping' to the frame
axe.<span class="apidocCodeKeywordSpan">utils.respondable</span>(win, 'axe.ping', null, undefined, function() {
  clearTimeout(timeout);
  // Give aXe 30s to respond to 'axe.start'
  timeout = setTimeout(function() {
    reject(err('Axe in frame timed out', node));
  }, 3e4);
  // send 'axe.start' and send the callback if it responded
  axe.utils.respondable(win, 'axe.start', parameters, undefined, function(data) {
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.axe-core.utils" id="apidoc.module.axe-core.utils">module axe-core.utils</a></h1>


    <h2>
        <a href="#apidoc.element.axe-core.utils.DqElement" id="apidoc.element.axe-core.utils.DqElement">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>DqElement
        <span class="apidocSignatureSpan">(element, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DqElement(element, spec) {
  'use strict';
  spec = spec || {};
<span class="apidocCodeCommentSpan">  /**
* A unique CSS selector for the element
* @type {String}
*/
</span>  this.selector = spec.selector || [ axe.utils.getSelector(element) ];
  /**
* Xpath to the element
*/
  this.xpath = spec.xpath || [ axe.utils.getXpath(element) ];
  /**
* The generated HTML source code of the element
* @type {String}
*/
  this.source = spec.source !== undefined ? spec.source : getSource(element);
  /**
* The element which this object is based off or the containing frame, used for sorting.
* Excluded in toJSON method.
* @type {HTMLElement}
*/
  this.element = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          });
          result[r.type] = res;
          if (res.length) {
            hasResults = true;
          }
        });
        if (hasResults) {
          result.node = new axe.utils.<span class="apidocCodeKeywordSpan">DqElement</span>(node);
          ruleResult.nodes.push(result);
        }
      }
      resolveNode();
    }).catch(rejectNode);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.aggregate" id="apidoc.element.axe-core.utils.aggregate">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregate
        <span class="apidocSignatureSpan">(map, values, initial)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aggregate = function (map, values, initial) {
  values = values.slice();
  if (initial) {
    values.push(initial);
  }
  var sorting = values.map(function(val) {
    return map.indexOf(val);
  }).sort();
  // Stupid NodeJS array.sort functor doesn't work!!
  return map[sorting.pop()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  nodeResult[type].forEach(function(check) {
    return impacts.push(check.impact);
  });
});
// for failed nodes, define the impact
if (nodeResult.priority === axe.constants.FAIL_PRIO) {
  nodeResult.impact = axe.utils.<span class="apidocCodeKeywordSpan">aggregate</span>(axe.constants.impact, impacts);
} else {
  nodeResult.impact = null;
}
// Delete the old result and priority properties
anyAllNone(nodeResult, function(c) {
  delete c.result;
  delete c.priority;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.aggregateChecks" id="apidoc.element.axe-core.utils.aggregateChecks">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregateChecks
        <span class="apidocSignatureSpan">(nodeResOriginal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aggregateChecks = function (nodeResOriginal) {
  // Create a copy
  var nodeResult = Object.assign({}, nodeResOriginal);
  // map each result value to a priority
  anyAllNone(nodeResult, function(check, type) {
    var i = checkMap.indexOf(check.result);
    // default to cantTell
    check.priority = i !== -1 ? i : axe.constants.CANTTELL_PRIO;
    if (type === 'none') {
      // For none, reverse the outcome
      check.priority = 4 - check.priority;
    }
  });
  // Find the result with the highest priority
  var priorities = anyAllNone(nodeResult, function(c) {
    return c.priority;
  });
  nodeResult.priority = Math.max(priorities.all.reduce(function(a, b) {
    return Math.max(a, b);
  }, 0), priorities.none.reduce(function(a, b) {
    return Math.max(a, b);
  }, 0), // get the lowest passing of 'any' defaulting
  // to 0 by wrapping around 4 to 0 (inapplicable)
  priorities.any.reduce(function(a, b) {
    return Math.min(a, b);
  }, 4) % 4);
  // Of each type, filter out all results not matching the final priority
  var impacts = [];
  checkTypes.forEach(function(type) {
    nodeResult[type] = nodeResult[type].filter(function(check) {
      return check.priority === nodeResult.priority;
    });
    nodeResult[type].forEach(function(check) {
      return impacts.push(check.impact);
    });
  });
  // for failed nodes, define the impact
  if (nodeResult.priority === axe.constants.FAIL_PRIO) {
    nodeResult.impact = axe.utils.aggregate(axe.constants.impact, impacts);
  } else {
    nodeResult.impact = null;
  }
  // Delete the old result and priority properties
  anyAllNone(nodeResult, function(c) {
    delete c.result;
    delete c.priority;
  });
  // Convert the index to a result string value
  nodeResult.result = axe.constants.results[nodeResult.priority];
  delete nodeResult.priority;
  return nodeResult;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  */
axe.utils.aggregateRule = function(subResults) {
  var ruleResult = {};
  // For each node, retrieve the result and impact
  subResults = subResults.map(function(subResult) {
    // Known result
    if (subResult.any &amp;&amp; subResult.all &amp;&amp; subResult.none) {
      return axe.utils.<span class="apidocCodeKeywordSpan">aggregateChecks</span>(subResult);
    } else {
      if (Array.isArray(subResult.node)) {
        return axe.utils.finalizeRuleResult(subResult);
      } else {
        throw new TypeError('Invalid Result type');
      }
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.aggregateResult" id="apidoc.element.axe-core.utils.aggregateResult">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregateResult
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aggregateResult = function (results) {
  var resultObject = {};
  // Create an array for each type
  axe.constants.resultGroups.forEach(function(groupName) {
    return resultObject[groupName] = [];
  });
  // Fill the array with nodes
  results.forEach(function(subResult) {
    if (subResult.error) {
      copyToGroup(resultObject, subResult, axe.constants.CANTTELL_GROUP);
    } else {
      if (subResult.result === axe.constants.NA) {
        copyToGroup(resultObject, subResult, axe.constants.NA_GROUP);
      } else {
        axe.constants.resultGroups.forEach(function(group) {
          if (Array.isArray(subResult[group]) &amp;&amp; subResult[group].length &gt; 0) {
            copyToGroup(resultObject, subResult, group);
          }
        });
      }
    }
  });
  return resultObject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return res;
      });
    });
  });
}
var resultKeys = axe.constants.resultGroups;
helpers.processAggregate = function(results, options) {
  var resultObject = axe.utils.<span class="apidocCodeKeywordSpan">aggregateResult</span>(results);
  resultObject.timestamp = new Date().toISOString();
  resultObject.url = window.location.href;
  resultKeys.forEach(function(key) {
    resultObject[key] = (resultObject[key] || []).map(function(ruleResult) {
      ruleResult = Object.assign({}, ruleResult);
      if (Array.isArray(ruleResult.nodes) &amp;&amp; ruleResult.nodes.length &gt; 0) {
        ruleResult.nodes = ruleResult.nodes.map(function(subResult) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.aggregateRule" id="apidoc.element.axe-core.utils.aggregateRule">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>aggregateRule
        <span class="apidocSignatureSpan">(subResults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aggregateRule = function (subResults) {
  var ruleResult = {};
  // For each node, retrieve the result and impact
  subResults = subResults.map(function(subResult) {
    // Known result
    if (subResult.any &amp;&amp; subResult.all &amp;&amp; subResult.none) {
      return axe.utils.aggregateChecks(subResult);
    } else {
      if (Array.isArray(subResult.node)) {
        return axe.utils.finalizeRuleResult(subResult);
      } else {
        throw new TypeError('Invalid Result type');
      }
    }
  });
  // Aggregate the result
  var resultList = subResults.map(function(node) {
    return node.result;
  });
  ruleResult.result = axe.utils.aggregate(axe.constants.results, resultList, ruleResult.result);
  // Create an array for each type
  axe.constants.resultGroups.forEach(function(group) {
    return ruleResult[group] = [];
  });
  // Fill the array with nodes
  subResults.forEach(function(subResult) {
    var groupName = axe.constants.resultGroupMap[subResult.result];
    ruleResult[groupName].push(subResult);
  });
  // Take the highest impact of failed rules
  var failGroup = axe.constants.FAIL_GROUP;
  if (ruleResult[failGroup].length &gt; 0) {
    // Get the impact of all violations
    var impactList = ruleResult[failGroup].map(function(failure) {
      return failure.impact;
    });
    ruleResult.impact = axe.utils.aggregate(axe.constants.impact, impactList) || null;
  } else {
    ruleResult.impact = null;
  }
  return ruleResult;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 'use strict';
 /**
* Process rule results, grouping them by outcome
* @param ruleResult {object}
* @return {object}
*/
 axe.utils.finalizeRuleResult = function(ruleResult) {
   Object.assign(ruleResult, axe.utils.<span class="apidocCodeKeywordSpan">aggregateRule</span>(ruleResult.nodes));
   delete ruleResult.nodes;
   return ruleResult;
 };
 'use strict';
 var _typeof = typeof Symbol === 'function' &amp;&amp; typeof Symbol.iterator === 'symbol' ? function(obj) {
   return typeof obj;
 } : function(obj) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.areStylesSet" id="apidoc.element.axe-core.utils.areStylesSet">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>areStylesSet
        <span class="apidocSignatureSpan">(el, styles, stopAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function areStylesSet(el, styles, stopAt) {
  'use strict';
  var styl = window.getComputedStyle(el, null);
  var set = false;
  if (!styl) {
    return false;
  }
  styles.forEach(function(att) {
    if (styl.getPropertyValue(att.property) === att.value) {
      set = true;
    }
  });
  if (set) {
    return true;
  }
  if (el.nodeName.toUpperCase() === stopAt.toUpperCase() || !el.parentNode) {
    return false;
  }
  return areStylesSet(el.parentNode, styles, stopAt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.checkHelper" id="apidoc.element.axe-core.utils.checkHelper">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>checkHelper
        <span class="apidocSignatureSpan">(checkResult, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkHelper(checkResult, resolve, reject) {
  'use strict';
  return {
    isAsync: false,
    async: function async() {
      this.isAsync = true;
      return function(result) {
        if (result instanceof Error === false) {
          checkResult.value = result;
          resolve(checkResult);
        } else {
          reject(result);
        }
      };
    },
    data: function data(_data) {
      checkResult.data = _data;
    },
    relatedNodes: function relatedNodes(nodes) {
      nodes = nodes instanceof Node ? [ nodes ] : axe.utils.toArray(nodes);
      checkResult.relatedNodes = nodes.map(function(element) {
        return new axe.utils.DqElement(element);
      });
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Check.prototype.run = function(node, options, resolve, reject) {
  'use strict';
  options = options || {};
  var enabled = options.hasOwnProperty('enabled') ? options.enabled : this.enabled, checkOptions = options.options ||
this.options;
  if (enabled) {
    var checkResult = new CheckResult(this);
    var checkHelper = axe.utils.<span class="apidocCodeKeywordSpan">checkHelper</span>(checkResult, resolve, reject);
    var result;
    try {
      result = this.evaluate.call(checkHelper, node, checkOptions);
    } catch (e) {
      reject(e);
      return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.clone" id="apidoc.element.axe-core.utils.clone">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (obj) {
  'use strict';
  var index, length, out = obj;
  if (obj !== null &amp;&amp; (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    if (Array.isArray(obj)) {
      out = [];
      for (index = 0, length = obj.length; index &lt; length; index++) {
        out[index] = axe.utils.clone(obj[index]);
      }
    } else {
      out = {};
      // jshint forin: false
      for (index in obj) {
        out[index] = axe.utils.clone(obj[index]);
      }
    }
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return obj &amp;&amp; typeof Symbol === 'function' &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol
.prototype ? 'symbol' : typeof obj;
};
/*global Rule, Check, RuleResult, commons: true */
function getDefaultConfiguration(audit) {
  'use strict';
  var config;
  if (audit) {
    config = axe.utils.<span class="apidocCodeKeywordSpan">clone</span>(audit);
    // Commons are configured into axe like everything else,
    // however because things go funky if we have multiple commons objects
    // we're not using the copy of that.
    config.commons = audit.commons;
  } else {
    config = {};
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.collectResultsFromFrames" id="apidoc.element.axe-core.utils.collectResultsFromFrames">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>collectResultsFromFrames
        <span class="apidocSignatureSpan">(context, options, command, parameter, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collectResultsFromFrames(context, options, command, parameter, resolve, reject) {
  'use strict';
  var q = axe.utils.queue();
  var frames = context.frames;
  // Tell each axe running in each frame to collect results
  frames.forEach(function(frame) {
    var params = {
      options: options,
      command: command,
      parameter: parameter,
      context: {
        initiator: false,
        page: context.page,
        include: frame.include || [],
        exclude: frame.exclude || []
      }
    };
    q.defer(function(res, rej) {
      var node = frame.node;
      axe.utils.sendCommandToFrame(node, params, function(data) {
        if (data) {
          return res({
            results: data,
            frameElement: node,
            frame: axe.utils.getSelector(node)
          });
        }
        res(null);
      }, rej);
    });
  });
  // Combine results from all frames and give it back
  q.then(function(data) {
    resolve(axe.utils.mergeResults(data));
  }).catch(reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function runRules(context, options, resolve, reject) {
'use strict';
context = new Context(context);
var q = axe.utils.queue();
var audit = axe._audit;
if (context.frames.length) {
  q.defer(function(res, rej) {
    axe.utils.<span class="apidocCodeKeywordSpan">collectResultsFromFrames</span>(context, options, 'rules', null, res
, rej);
  });
}
q.defer(function(res, rej) {
  audit.run(context, options, res, rej);
});
q.then(function(data) {
  try {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.contains" id="apidoc.element.axe-core.utils.contains">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>contains
        <span class="apidocSignatureSpan">(node, otherNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (node, otherNode) {
  //jshint bitwise: false
  'use strict';
  if (typeof node.contains === 'function') {
    return node.contains(otherNode);
  }
  return !!(node.compareDocumentPosition(otherNode) &amp; 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {HTMLElement} otherNode The node to test is contained by `node`
* @return {Boolean}           Whether `node` contains `otherNode`
*/
 axe.utils.contains = function(node, otherNode) {
   //jshint bitwise: false
   'use strict';
   if (typeof node.contains === 'function') {
     return node.<span class="apidocCodeKeywordSpan">contains</span>(otherNode);
   }
   return !!(node.compareDocumentPosition(otherNode) &amp; 16);
 };
 'use strict';
 /*exported DqElement */
 function truncate(str, maxLength) {
   'use strict';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.escapeSelector" id="apidoc.element.axe-core.utils.escapeSelector">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>escapeSelector
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeSelector = function (value) {
  'use strict';
<span class="apidocCodeCommentSpan">  /*jshint bitwise: true, eqeqeq: false, maxcomplexity: 14, maxstatements: 23, onevar: false, -W041: false */
</span>  var string = String(value);
  var length = string.length;
  var index = -1;
  var codeUnit;
  var result = '';
  var firstCodeUnit = string.charCodeAt(0);
  while (++index &lt; length) {
    codeUnit = string.charCodeAt(index);
    // Note: theres no need to special-case astral symbols, surrogate
    // pairs, or lone surrogates.
    // If the character is NULL (U+0000), then throw an
    // `InvalidCharacterError` exception and terminate these steps.
    if (codeUnit == 0) {
      throw new Error('INVALID_CHARACTER_ERR');
    }
    if (// If the character is in the range [\1-\1F] (U+0001 to U+001F) or
    // [\7F-\9F] (U+007F to U+009F), []
    codeUnit &gt;= 1 &amp;&amp; codeUnit &lt;= 31 || codeUnit &gt;= 127 &amp;&amp; codeUnit &lt;= 159 || // If the character is the first character and is in
 the range [0-9]
    // (U+0030 to U+0039), []
    index == 0 &amp;&amp; codeUnit &gt;= 48 &amp;&amp; codeUnit &lt;= 57 || // If the character is the second character and is in the range [0-9]
    // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
    index == 1 &amp;&amp; codeUnit &gt;= 48 &amp;&amp; codeUnit &lt;= 57 &amp;&amp; firstCodeUnit == 45) {
      // http://dev.w3.org/csswg/cssom/#escape-a-character-as-code-point
      result += '\\' + codeUnit.toString(16) + ' ';
      continue;
    }
    // If the character is the second character and is `-` (U+002D) and the
    // first character is `-` as well, []
    if (index == 1 &amp;&amp; codeUnit == 45 &amp;&amp; firstCodeUnit == 45) {
      // http://dev.w3.org/csswg/cssom/#escape-a-character
      result += '\\' + string.charAt(index);
      continue;
    }
    // If the character is not handled by one of the above rules and is
    // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
    // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
    // U+005A), or [a-z] (U+0061 to U+007A), []
    if (codeUnit &gt;= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit &gt;= 48 &amp;&amp; codeUnit &lt;= 57 || codeUnit &gt;= 65 &amp;&amp; codeUnit &lt;=
90 || codeUnit &gt;= 97 &amp;&amp; codeUnit &lt;= 122) {
      // the character itself
      result += string.charAt(index);
      continue;
    }
    // Otherwise, the escaped character.
    // http://dev.w3.org/csswg/cssom/#escape-a-character
    result += '\\' + string.charAt(index);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {HTMLElement} node The element to get the selector for
* @return {String}      Unique CSS selector for the node
*/
 axe.utils.getSelector = function getSelector(node) {
   //jshint maxstatements: 21
   'use strict';
   function escape(p) {
     return axe.utils.<span class="apidocCodeKeywordSpan">escapeSelector</span>(p);
   }
   var parts = [], part;
   while (node.parentNode) {
     part = '';
     if (node.id &amp;&amp; document.querySelectorAll('#' + axe.utils.escapeSelector(node.id)).length === 1) {
       parts.unshift('#' + axe.utils.escapeSelector(node.id));
       break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.extendMetaData" id="apidoc.element.axe-core.utils.extendMetaData">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>extendMetaData
        <span class="apidocSignatureSpan">(to, from)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendMetaData = function (to, from) {
  Object.assign(to, from);
  Object.keys(from).filter(function(prop) {
    return typeof from[prop] === 'function';
  }).forEach(function(prop) {
    to[prop] = null;
    try {
      to[prop] = from[prop](to);
    } catch (e) {}
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   'use strict';
   return function(check) {
     var sourceData = checksData[check.id] || {};
     var messages = sourceData.messages || {};
     var data = Object.assign({}, sourceData);
     delete data.messages;
     data.message = check.result === shouldBeTrue ? messages.pass : messages.fail;
     axe.utils.<span class="apidocCodeKeywordSpan">extendMetaData</span>(check, data);
   };
 }
 /**
* Publish metadata from axe._audit.data
* @param  {RuleResult} result Result to publish to
* @private
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.finalizeRuleResult" id="apidoc.element.axe-core.utils.finalizeRuleResult">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>finalizeRuleResult
        <span class="apidocSignatureSpan">(ruleResult)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalizeRuleResult = function (ruleResult) {
  Object.assign(ruleResult, axe.utils.aggregateRule(ruleResult.nodes));
  delete ruleResult.nodes;
  return ruleResult;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// For each node, retrieve the result and impact
subResults = subResults.map(function(subResult) {
  // Known result
  if (subResult.any &amp;&amp; subResult.all &amp;&amp; subResult.none) {
    return axe.utils.aggregateChecks(subResult);
  } else {
    if (Array.isArray(subResult.node)) {
      return axe.utils.<span class="apidocCodeKeywordSpan">finalizeRuleResult</span>(subResult);
    } else {
      throw new TypeError('Invalid Result type');
    }
  }
});
// Aggregate the result
var resultList = subResults.map(function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.findBy" id="apidoc.element.axe-core.utils.findBy">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>findBy
        <span class="apidocSignatureSpan">(array, key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findBy = function (array, key, value) {
  if (Array.isArray(array)) {
    return array.find(function(obj) {
      return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' &amp;&amp; obj[key] === value;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {Array} results  Array of RuleResults to postprocess
* @param  {Mixed} options  Options object to pass into rules and/or disable rules or checks
*/
 Audit.prototype.after = function(results, options) {
   'use strict';
   var rules = this.rules;
   return results.map(function(ruleResult) {
     var rule = axe.utils.<span class="apidocCodeKeywordSpan">findBy</span>(rules, 'id', ruleResult.id);
     return rule.after(ruleResult, options);
   });
 };
 /**
* Get the rule with a given ID
* @param  {string}
* @return {Rule}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.getAllChecks" id="apidoc.element.axe-core.utils.getAllChecks">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>getAllChecks
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllChecks(object) {
  'use strict';
  var result = [];
  return result.concat(object.any || []).concat(object.all || []).concat(object.none || []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Iterates the rule's Checks looking for ones that have an after function
* @private
* @param  {Rule} rule The rule to check for after checks
* @return {Array}      Checks that have an after function
*/
 function findAfterChecks(rule) {
   'use strict';
   return axe.utils.<span class="apidocCodeKeywordSpan">getAllChecks</span>(rule).map(function(c) {
     var check = rule._audit.checks[c.id || c];
     return check &amp;&amp; typeof check.after === 'function' ? check : null;
   }).filter(Boolean);
 }
 /**
* Finds and collates all results for a given Check on a specific Rule
* @private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.getCheckOption" id="apidoc.element.axe-core.utils.getCheckOption">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>getCheckOption
        <span class="apidocSignatureSpan">(check, ruleID, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCheckOption = function (check, ruleID, options) {
  'use strict';
  var ruleCheckOption = ((options.rules &amp;&amp; options.rules[ruleID] || {}).checks || {})[check.id];
  var checkOption = (options.checks || {})[check.id];
  var enabled = check.enabled;
  var opts = check.options;
  if (checkOption) {
    if (checkOption.hasOwnProperty('enabled')) {
      enabled = checkOption.enabled;
    }
    if (checkOption.hasOwnProperty('options')) {
      opts = checkOption.options;
    }
  }
  if (ruleCheckOption) {
    if (ruleCheckOption.hasOwnProperty('enabled')) {
      enabled = ruleCheckOption.enabled;
    }
    if (ruleCheckOption.hasOwnProperty('options')) {
      opts = ruleCheckOption.options;
    }
  }
  return {
    enabled: enabled,
    options: opts
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Rule.prototype.runChecks = function(type, node, options, resolve, reject) {
  'use strict';
  var self = this;
  var checkQueue = axe.utils.queue();
  this[type].forEach(function(c) {
    var check = self._audit.checks[c.id || c];
    var option = axe.utils.<span class="apidocCodeKeywordSpan">getCheckOption</span>(check, self.id, options);
    checkQueue.defer(function(res, rej) {
      check.run(node, option, res, rej);
    });
  });
  checkQueue.then(function(results) {
    results = results.filter(function(check) {
      return check;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.getSelector" id="apidoc.element.axe-core.utils.getSelector">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>getSelector
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSelector(node) {
  //jshint maxstatements: 21
  'use strict';
  function escape(p) {
    return axe.utils.escapeSelector(p);
  }
  var parts = [], part;
  while (node.parentNode) {
    part = '';
    if (node.id &amp;&amp; document.querySelectorAll('#' + axe.utils.escapeSelector(node.id)).length === 1) {
      parts.unshift('#' + axe.utils.escapeSelector(node.id));
      break;
    }
    if (node.className &amp;&amp; typeof node.className === 'string') {
      part = '.' + node.className.trim().split(/\s+/).map(escape).join('.');
      if (part === '.' || siblingsHaveSameSelector(node, part)) {
        part = '';
      }
    }
    if (!part) {
      part = axe.utils.escapeSelector(node.nodeName).toLowerCase();
      if (part === 'html' || part === 'body') {
        parts.unshift(part);
        break;
      }
      if (siblingsHaveSameSelector(node, part)) {
        part += ':nth-of-type(' + nthOfType(node) + ')';
      }
    }
    parts.unshift(part);
    node = node.parentNode;
  }
  return parts.join(' &gt; ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     }
   }
   return out;
 };
 'use strict';
 function err(message, node) {
   'use strict';
   return new Error(message + ': ' + axe.utils.<span class="apidocCodeKeywordSpan">getSelector</span>(node));
 }
 /**
* Sends a command to an instance of axe in the specified frame
* @param  {Element}  node       The frame element to send the message to
* @param  {Object}   parameters Parameters to pass to the frame
* @param  {Function} callback   Function to call when results from the frame has returned
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.getXpath" id="apidoc.element.axe-core.utils.getXpath">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>getXpath
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getXpath(node) {
  var xpathArray = getXPathArray(node);
  return xpathToString(xpathArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* A unique CSS selector for the element
* @type {String}
*/
  this.selector = spec.selector || [ axe.utils.getSelector(element) ];
  /**
* Xpath to the element
*/
  this.xpath = spec.xpath || [ axe.utils.<span class="apidocCodeKeywordSpan">getXpath</span>(element) ];
  /**
* The generated HTML source code of the element
* @type {String}
*/
  this.source = spec.source !== undefined ? spec.source : getSource(element);
  /**
* The element which this object is based off or the containing frame, used for sorting.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.injectStyle" id="apidoc.element.axe-core.utils.injectStyle">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>injectStyle
        <span class="apidocSignatureSpan">(style)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function injectStyle(style) {
  'use strict';
  if (styleSheet &amp;&amp; styleSheet.parentNode) {
    // append the style to the existing sheet
    if (styleSheet.styleSheet === undefined) {
      // Not old IE
      styleSheet.appendChild(document.createTextNode(style));
    } else {
      styleSheet.styleSheet.cssText += style;
    }
    return styleSheet;
  }
  if (!style) {
    return;
  }
  var head = document.head || document.getElementsByTagName('head')[0];
  styleSheet = document.createElement('style');
  styleSheet.type = 'text/css';
  if (styleSheet.styleSheet === undefined) {
    // Not old IE
    styleSheet.appendChild(document.createTextNode(style));
  } else {
    styleSheet.styleSheet.cssText = style;
  }
  head.appendChild(styleSheet);
  return styleSheet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.isHidden" id="apidoc.element.axe-core.utils.isHidden">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>isHidden
        <span class="apidocSignatureSpan">(el, recursed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isHidden(el, recursed) {
  'use strict';
  // 9 === Node.DOCUMENT
  if (el.nodeType === 9) {
    return false;
  }
  var style = window.getComputedStyle(el, null);
  if (!style || !el.parentNode || style.getPropertyValue('display') === 'none' || !recursed &amp;&amp; // visibility is only accurate on
 the first element
  style.getPropertyValue('visibility') === 'hidden' || el.getAttribute('aria-hidden') === 'true') {
    return true;
  }
  return axe.utils.isHidden(el.parentNode, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Pushes a unique frame onto `frames` array, filtering any hidden iframes
* @private
* @param  {Array} collection The array of unique frames that is being operated on
* @param  {HTMLElement} frame   The frame to push onto Context
*/
 function pushUniqueFrame(collection, frame) {
   'use strict';
   if (axe.utils.<span class="apidocCodeKeywordSpan">isHidden</span>(frame)) {
     return;
   }
   var fr = axe.utils.findBy(collection, 'node', frame);
   if (!fr) {
     collection.push({
       node: frame,
       include: [],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.matchesSelector" id="apidoc.element.axe-core.utils.matchesSelector">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>matchesSelector
        <span class="apidocSignatureSpan">(node, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">matchesSelector = function (node, selector) {
  if (!method || !node[method]) {
    method = getMethod(node.ownerDocument.defaultView);
  }
  return node[method](selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   var index, sibling, siblings = node.parentNode.children;
   if (!siblings) {
     return false;
   }
   var length = siblings.length;
   for (index = 0; index &lt; length; index++) {
     sibling = siblings[index];
     if (sibling !== node &amp;&amp; axe.utils.<span class="apidocCodeKeywordSpan">matchesSelector</span>(sibling, selector)) {
       return true;
     }
   }
   return false;
 }
 /**
* Gets a unique CSS selector
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.mergeResults" id="apidoc.element.axe-core.utils.mergeResults">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>mergeResults
        <span class="apidocSignatureSpan">(frameResults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeResults(frameResults) {
  'use strict';
  var result = [];
  frameResults.forEach(function(frameResult) {
    var results = normalizeResult(frameResult);
    if (!results || !results.length) {
      return;
    }
    results.forEach(function(ruleResult) {
      if (ruleResult.nodes &amp;&amp; frameResult.frame) {
        pushFrame(ruleResult.nodes, frameResult.frameElement, frameResult.frame);
      }
      var res = axe.utils.findBy(result, 'id', ruleResult.id);
      if (!res) {
        result.push(ruleResult);
      } else {
        if (ruleResult.nodes.length) {
          spliceNodes(res.nodes, ruleResult.nodes);
        }
      }
    });
  });
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
q.defer(function(res, rej) {
  audit.run(context, options, res, rej);
});
q.then(function(data) {
  try {
    // Add wrapper object so that we may use the same "merge" function for results from inside and outside frames
    var results = axe.utils.<span class="apidocCodeKeywordSpan">mergeResults</span>(data.map(function(d) {
      return {
        results: d
      };
    }));
    // after should only run once, so ensure we are in the top level window
    if (context.initiator) {
      results = audit.after(results, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.nodeSorter" id="apidoc.element.axe-core.utils.nodeSorter">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>nodeSorter
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nodeSorter(a, b) {
<span class="apidocCodeCommentSpan">  /*jshint bitwise: false */
</span>  'use strict';
  if (a === b) {
    return 0;
  }
  if (a.compareDocumentPosition(b) &amp; 4) {
    // a before b
    return -1;
  }
  return 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @return {Array}      The merged and sorted result
*/
function spliceNodes(target, to) {
  'use strict';
  var firstFromFrame = to[0].node, sorterResult, t;
  for (var i = 0, l = target.length; i &lt; l; i++) {
    t = target[i].node;
    sorterResult = axe.utils.<span class="apidocCodeKeywordSpan">nodeSorter</span>(t.element, firstFromFrame.element);
    if (sorterResult &gt; 0 || sorterResult === 0 &amp;&amp; firstFromFrame.selector.length &lt; t.selector.length) {
      target.splice.apply(target, [ i, 0 ].concat(to));
      return;
    }
  }
  target.push.apply(target, to);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.pollyfillElementsFromPoint" id="apidoc.element.axe-core.utils.pollyfillElementsFromPoint">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>pollyfillElementsFromPoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pollyfillElementsFromPoint = function () {
  if (document.elementsFromPoint) {
    return document.elementsFromPoint;
  }
  if (document.msElementsFromPoint) {
    return document.msElementsFromPoint;
  }
  var usePointer = function() {
    var element = document.createElement('x');
    element.style.cssText = 'pointer-events:auto';
    return element.style.pointerEvents === 'auto';
  }();
  var cssProp = usePointer ? 'pointer-events' : 'visibility';
  var cssDisableVal = usePointer ? 'none' : 'hidden';
  var style = document.createElement('style');
  style.innerHTML = usePointer ? '* { pointer-events: all }' : '* { visibility: visible }';
  return function(x, y) {
    var current, i, d;
    var elements = [];
    var previousPointerEvents = [];
    // startup
    document.head.appendChild(style);
    while ((current = document.elementFromPoint(x, y)) &amp;&amp; elements.indexOf(current) === -1) {
      // push the element and its current style
      elements.push(current);
      previousPointerEvents.push({
        value: current.style.getPropertyValue(cssProp),
        priority: current.style.getPropertyPriority(cssProp)
      });
      // add "pointer-events: none", to get to the underlying element
      current.style.setProperty(cssProp, cssDisableVal, 'important');
    }
    // restore the previous pointer-events values
    for (i = previousPointerEvents.length; !!(d = previousPointerEvents[--i]); ) {
      elements[i].style.setProperty(cssProp, d.value ? d.value : '', d.priority);
    }
    // teardown;
    document.head.removeChild(style);
    return elements;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    // teardown;
    document.head.removeChild(style);
    return elements;
  };
};
if (typeof window.addEventListener === 'function') {
  document.elementsFromPoint = axe.utils.<span class="apidocCodeKeywordSpan">pollyfillElementsFromPoint</span>();
}
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement) {
    'use strict';
    var O = Object(this);
    var len = parseInt(O.length, 10) || 0;
    if (len === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.publishMetaData" id="apidoc.element.axe-core.utils.publishMetaData">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>publishMetaData
        <span class="apidocSignatureSpan">(ruleResult)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">publishMetaData = function (ruleResult) {
  'use strict';
  var checksData = axe._audit.data.checks || {};
  var rulesData = axe._audit.data.rules || {};
  var rule = axe.utils.findBy(axe._audit.rules, 'id', ruleResult.id) || {};
  ruleResult.tags = axe.utils.clone(rule.tags || []);
  var shouldBeTrue = extender(checksData, true);
  var shouldBeFalse = extender(checksData, false);
  ruleResult.nodes.forEach(function(detail) {
    detail.any.forEach(shouldBeTrue);
    detail.all.forEach(shouldBeTrue);
    detail.none.forEach(shouldBeFalse);
  });
  axe.utils.extendMetaData(ruleResult, axe.utils.clone(rulesData[ruleResult.id] || {}));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.queue" id="apidoc.element.axe-core.utils.queue">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>queue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queue() {
  var tasks = [];
  var started = 0;
  var remaining = 0;
  // number of tasks not yet finished
  var completeQueue = noop;
  var complete = false;
  var err;
  // By default, wait until the next tick,
  // if no catch was set, throw to console.
  var defaultFail = function defaultFail(e) {
    err = e;
    setTimeout(function() {
      if (err !== undefined &amp;&amp; err !== null) {
        axe.log('Uncaught error (of queue)', err);
      }
    }, 1);
  };
  var failed = defaultFail;
  function createResolve(i) {
    return function(r) {
      tasks[i] = r;
      remaining -= 1;
      if (!remaining &amp;&amp; completeQueue !== noop) {
        complete = true;
        completeQueue(tasks);
      }
    };
  }
  function abort(msg) {
    // reset tasks
    completeQueue = noop;
    // notify catch
    failed(msg);
    // return unfinished work
    return tasks;
  }
  function pop() {
    var length = tasks.length;
    for (;started &lt; length; started++) {
      var task = tasks[started];
      try {
        task.call(null, createResolve(started), abort);
      } catch (e) {
        abort(e);
      }
    }
  }
  var q = {
<span class="apidocCodeCommentSpan">    /**
* Defer a function that may or may not run asynchronously.
*
* First parameter should be the function to execute with subsequent
* parameters being passed as arguments to that function
*/
</span>    defer: function defer(fn) {
      if ((typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === 'object' &amp;&amp; fn.then &amp;&amp; fn.catch) {
        var defer = fn;
        fn = function fn(resolve, reject) {
          defer.then(resolve).catch(reject);
        };
      }
      funcGuard(fn);
      if (err !== undefined) {
        return;
      } else {
        if (complete) {
          throw new Error('Queue already completed');
        }
      }
      tasks.push(fn);
      ++remaining;
      pop();
      return q;
    },
    /**
* The callback to execute once all "deferred" functions have completed.  Will only be invoked once.
* @param  {Function} f The callback, receives an array of the return/callbacked
* values of each of the "deferred" functions
*/
    then: function then(fn) {
      funcGuard(fn);
      if (completeQueue !== noop) {
        throw new Error('queue `then` already set');
      }
      if (!err) {
        completeQueue = fn;
        if (!remaining) {
          complete = true;
          completeQueue(tasks);
        }
      }
      return q;
    },
    'catch': function _catch(fn) {
      funcGuard(fn);
      if (failed !== defaultFail) {
        throw new Error('queue `catch` already set');
      }
      if (!err) {
        failed = fn;
      } else {
        fn(err);
        err = null;
      }
      return q;
    },
    /**
* Abort the "queue" and prevent `then` function from firing
* @param  {Function} fn The callback to execute; receives an array of the results which have completed
*/
    abort: abort
  };
  return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {Context}   context The scope definition/context for analysis (include/exclude)
* @param  {Object}    options Options object to pass into rules and/or disable rules or checks
* @param  {Function} fn       Callback function to fire when audit is complete
*/
 Audit.prototype.run = function(context, options, resolve, reject) {
   'use strict';
   this.validateOptions(options);
   var q = axe.utils.<span class="apidocCodeKeywordSpan">queue</span>();
   this.rules.forEach(function(rule) {
     if (axe.utils.ruleShouldRun(rule, context, options)) {
       q.defer(function(res, rej) {
         rule.run(context, options, res, function(err) {
           if (!options.debug) {
             var errResult = Object.assign(new RuleResult(rule), {
               result: axe.constants.CANTTELL,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.respondable" id="apidoc.element.axe-core.utils.respondable">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>respondable
        <span class="apidocSignatureSpan">(win, topic, message, keepalive, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function respondable(win, topic, message, keepalive, callback) {
  var id = uuid.v1();
  post(win, topic, message, id, keepalive, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      resolve(null);
    } else {
      reject(errMsg);
    }
  }, 0);
}, 500);
// send 'axe.ping' to the frame
axe.utils.<span class="apidocCodeKeywordSpan">respondable</span>(win, 'axe.ping', null, undefined, function() {
  clearTimeout(timeout);
  // Give aXe 30s to respond to 'axe.start'
  timeout = setTimeout(function() {
    reject(err('Axe in frame timed out', node));
  }, 3e4);
  // send 'axe.start' and send the callback if it responded
  axe.utils.respondable(win, 'axe.start', parameters, undefined, function(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.ruleShouldRun" id="apidoc.element.axe-core.utils.ruleShouldRun">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>ruleShouldRun
        <span class="apidocSignatureSpan">(rule, context, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ruleShouldRun = function (rule, context, options) {
  'use strict';
  var runOnly = options.runOnly || {};
  var ruleOptions = (options.rules || {})[rule.id];
  // Never run page level rules if the context is not on the page
  if (rule.pageLevel &amp;&amp; !context.page) {
    return false;
  } else {
    if (runOnly.type === 'rule') {
      return runOnly.values.indexOf(rule.id) !== -1;
    } else {
      if (ruleOptions &amp;&amp; typeof ruleOptions.enabled === 'boolean') {
        return ruleOptions.enabled;
      } else {
        if (runOnly.type === 'tag' &amp;&amp; runOnly.values) {
          return matchTags(rule, runOnly.values);
        } else {
          return matchTags(rule, []);
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {Function} fn       Callback function to fire when audit is complete
*/
 Audit.prototype.run = function(context, options, resolve, reject) {
   'use strict';
   this.validateOptions(options);
   var q = axe.utils.queue();
   this.rules.forEach(function(rule) {
     if (axe.utils.<span class="apidocCodeKeywordSpan">ruleShouldRun</span>(rule, context, options)) {
       q.defer(function(res, rej) {
         rule.run(context, options, res, function(err) {
           if (!options.debug) {
             var errResult = Object.assign(new RuleResult(rule), {
               result: axe.constants.CANTTELL,
               description: 'An error occured while running this rule',
               message: err.message,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.select" id="apidoc.element.axe-core.utils.select">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>select
        <span class="apidocSignatureSpan">(selector, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function select(selector, context) {
  'use strict';
  var result = [], candidate;
  for (var i = 0, l = context.include.length; i &lt; l; i++) {
    candidate = context.include[i];
    if (candidate.nodeType === candidate.ELEMENT_NODE &amp;&amp; axe.utils.matchesSelector(candidate, selector)) {
      pushNode(result, [ candidate ], context);
    }
    pushNode(result, candidate.querySelectorAll(selector), context);
  }
  return result.sort(axe.utils.nodeSorter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.initiator = spec &amp;&amp; typeof spec.initiator === 'boolean' ? spec.initiator : true;
this.page = false;
spec = normalizeContext(spec);
this.exclude = spec.exclude;
this.include = spec.include;
this.include = parseSelectorArray(this, 'include');
this.exclude = parseSelectorArray(this, 'exclude');
axe.utils.<span class="apidocCodeKeywordSpan">select</span>('frame, iframe', this).forEach(function(frame) {
  if (isNodeInContext(frame, self)) {
    pushUniqueFrame(self.frames, frame);
  }
});
if (this.include.length === 1 &amp;&amp; this.include[0] === document) {
  this.page = true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.sendCommandToFrame" id="apidoc.element.axe-core.utils.sendCommandToFrame">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>sendCommandToFrame
        <span class="apidocSignatureSpan">(node, parameters, resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendCommandToFrame = function (node, parameters, resolve, reject) {
  'use strict';
  var win = node.contentWindow;
  if (!win) {
    axe.log('Frame does not have a content window', node);
    resolve(null);
    return;
  }
  // give the frame .5s to respond to 'axe.ping', else log failed response
  var timeout = setTimeout(function() {
    // This double timeout is important for allowing iframes to respond
    // DO NOT REMOVE
    timeout = setTimeout(function() {
      var errMsg = err('No response from frame', node);
      if (!parameters.debug) {
        axe.log(errMsg);
        resolve(null);
      } else {
        reject(errMsg);
      }
    }, 0);
  }, 500);
  // send 'axe.ping' to the frame
  axe.utils.respondable(win, 'axe.ping', null, undefined, function() {
    clearTimeout(timeout);
    // Give aXe 30s to respond to 'axe.start'
    timeout = setTimeout(function() {
      reject(err('Axe in frame timed out', node));
    }, 3e4);
    // send 'axe.start' and send the callback if it responded
    axe.utils.respondable(win, 'axe.start', parameters, undefined, function(data) {
      clearTimeout(timeout);
      if (data instanceof Error === false) {
        resolve(data);
      } else {
        reject(data);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } catch (err) {
      rej(err);
    }
  });
});
axe.utils.toArray(document.querySelectorAll('frame, iframe')).forEach(function(frame) {
  q.defer(function(res, rej) {
    return axe.utils.<span class="apidocCodeKeywordSpan">sendCommandToFrame</span>(frame, {
      command: 'cleanup-plugin'
    }, res, rej);
  });
});
q.then(function(results) {
  if (cleanupErrors.length === 0) {
    resolve(results);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.toArray" id="apidoc.element.axe-core.utils.toArray">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>toArray
        <span class="apidocSignatureSpan">(thing)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function (thing) {
  'use strict';
  return Array.prototype.slice.call(thing);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function parseSelectorArray(context, type) {
'use strict';
var item, result = [];
for (var i = 0, l = context[type].length; i &lt; l; i++) {
  item = context[type][i];
  // selector
  if (typeof item === 'string') {
    result = result.concat(axe.utils.<span class="apidocCodeKeywordSpan">toArray</span>(document.querySelectorAll(item)));
    break;
  } else {
    if (item &amp;&amp; item.length &amp;&amp; !(item instanceof Node)) {
      if (item.length &gt; 1) {
        pushUniqueFrameSelector(context, type, item);
      } else {
        result = result.concat(axe.utils.toArray(document.querySelectorAll(item[0])));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.tokenList" id="apidoc.element.axe-core.utils.tokenList">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>tokenList
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenList = function (str) {
  'use strict';
  return str.trim().replace(/\s{2,}/g, ' ').split(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
        switch (attrInfo.type) {
case 'boolean':
case 'nmtoken':
 return typeof value === 'string' &amp;&amp; attrInfo.values.indexOf(value.toLowerCase()) !== -1;

case 'nmtokens':
 list = axe.utils.<span class="apidocCodeKeywordSpan">tokenList</span>(value);
 // Check if any value isn't in the list of values
 return list.reduce(function(result, token) {
   return result &amp;&amp; attrInfo.values.indexOf(token) !== -1;
 }, list.length !== 0);

case 'idref':
 return !!(value &amp;&amp; doc.getElementById(value));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.axe-core.utils.DqElement" id="apidoc.module.axe-core.utils.DqElement">module axe-core.utils.DqElement</a></h1>


    <h2>
        <a href="#apidoc.element.axe-core.utils.DqElement.DqElement" id="apidoc.element.axe-core.utils.DqElement.DqElement">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>DqElement
        <span class="apidocSignatureSpan">(element, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DqElement(element, spec) {
  'use strict';
  spec = spec || {};
<span class="apidocCodeCommentSpan">  /**
* A unique CSS selector for the element
* @type {String}
*/
</span>  this.selector = spec.selector || [ axe.utils.getSelector(element) ];
  /**
* Xpath to the element
*/
  this.xpath = spec.xpath || [ axe.utils.getXpath(element) ];
  /**
* The generated HTML source code of the element
* @type {String}
*/
  this.source = spec.source !== undefined ? spec.source : getSource(element);
  /**
* The element which this object is based off or the containing frame, used for sorting.
* Excluded in toJSON method.
* @type {HTMLElement}
*/
  this.element = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          });
          result[r.type] = res;
          if (res.length) {
            hasResults = true;
          }
        });
        if (hasResults) {
          result.node = new axe.utils.<span class="apidocCodeKeywordSpan">DqElement</span>(node);
          ruleResult.nodes.push(result);
        }
      }
      resolveNode();
    }).catch(rejectNode);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.DqElement.fromFrame" id="apidoc.element.axe-core.utils.DqElement.fromFrame">
        function <span class="apidocSignatureSpan">axe-core.utils.DqElement.</span>fromFrame
        <span class="apidocSignatureSpan">(node, frame)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromFrame = function (node, frame) {
  node.selector.unshift(frame.selector);
  node.xpath.unshift(frame.xpath);
  return new axe.utils.DqElement(frame.element, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var frameXpath = axe.utils.getXpath(frameElement);
var frameSpec = {
  element: frameElement,
  selector: frameSelector,
  xpath: frameXpath
};
resultSet.forEach(function(res) {
  res.node = axe.utils.DqElement.<span class="apidocCodeKeywordSpan">fromFrame</span>(res.node, frameSpec);
  var checks = axe.utils.getAllChecks(res);
  if (checks.length) {
    checks.forEach(function(check) {
      check.relatedNodes = check.relatedNodes.map(function(node) {
        return axe.utils.DqElement.fromFrame(node, frameSpec);
      });
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.axe-core.utils.DqElement.prototype" id="apidoc.module.axe-core.utils.DqElement.prototype">module axe-core.utils.DqElement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.axe-core.utils.DqElement.prototype.toJSON" id="apidoc.element.axe-core.utils.DqElement.prototype.toJSON">
        function <span class="apidocSignatureSpan">axe-core.utils.DqElement.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  'use strict';
  return {
    selector: this.selector,
    source: this.source,
    xpath: this.xpath
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.axe-core.utils.respondable" id="apidoc.module.axe-core.utils.respondable">module axe-core.utils.respondable</a></h1>


    <h2>
        <a href="#apidoc.element.axe-core.utils.respondable.respondable" id="apidoc.element.axe-core.utils.respondable.respondable">
        function <span class="apidocSignatureSpan">axe-core.utils.</span>respondable
        <span class="apidocSignatureSpan">(win, topic, message, keepalive, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function respondable(win, topic, message, keepalive, callback) {
  var id = uuid.v1();
  post(win, topic, message, id, keepalive, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      resolve(null);
    } else {
      reject(errMsg);
    }
  }, 0);
}, 500);
// send 'axe.ping' to the frame
axe.utils.<span class="apidocCodeKeywordSpan">respondable</span>(win, 'axe.ping', null, undefined, function() {
  clearTimeout(timeout);
  // Give aXe 30s to respond to 'axe.start'
  timeout = setTimeout(function() {
    reject(err('Axe in frame timed out', node));
  }, 3e4);
  // send 'axe.start' and send the callback if it responded
  axe.utils.respondable(win, 'axe.start', parameters, undefined, function(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.respondable.isInFrame" id="apidoc.element.axe-core.utils.respondable.isInFrame">
        function <span class="apidocSignatureSpan">axe-core.utils.respondable.</span>isInFrame
        <span class="apidocSignatureSpan">(win)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInFrame = function (win) {
  win = win || window;
  return !!win.frameElement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param  {context} context
* @return {Error}
*/
 function validateContext(context) {
   'use strict';
   if (context.include.length === 0) {
     if (context.frames.length === 0) {
       var env = axe.utils.respondable.<span class="apidocCodeKeywordSpan">isInFrame</span>() ? 'frame' : 'page&amp;#
x27;;
       return new Error('No elements found for include in ' + env + ' Context');
     }
     context.frames.forEach(function(frame, i) {
       if (frame.include.length === 0) {
         return new Error('No elements found for include in Context of frame ' + i);
       }
     });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.axe-core.utils.respondable.subscribe" id="apidoc.element.axe-core.utils.respondable.subscribe">
        function <span class="apidocSignatureSpan">axe-core.utils.respondable.</span>subscribe
        <span class="apidocSignatureSpan">(topic, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (topic, callback) {
  subscribers[topic] = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 /**
* Sets up Rules, Messages and default options for Checks, must be invoked before attempting analysis
* @param  {Object} audit The "audit specification" object
* @private
*/
 axe._load = function(audit) {
   'use strict';
   axe.utils.respondable.<span class="apidocCodeKeywordSpan">subscribe</span>('axe.ping', function(data, keepalive, respond
) {
     respond({
       axe: true
     });
   });
   axe.utils.respondable.subscribe('axe.start', runCommand);
   axe._audit = new Audit(audit);
 };
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>